// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/** Collects several code emitters for the template tool. */
library emitters;

import 'package:html5lib/dom.dart';
import 'package:html5lib/dom_parsing.dart';

import 'code_printer.dart';
import 'codegen.dart' as codegen;
import 'html5_utils.dart';
import 'html5_setters.g.dart';
import 'info.dart';
import 'messages.dart';
import 'utils.dart';

/**
 * Context used by an emitter. Typically representing where to generate code
 * and additional information, such as total number of generated identifiers.
 */
class Context {
  final Declarations declarations;
  final CodePrinter printer;
  final bool isClass;

  Context({Declarations declarations,
           CodePrinter printer,
           bool isClass: false})
      : this.declarations =
            declarations != null ? declarations : new Declarations(!isClass),
        this.isClass = isClass,
        this.printer = printer != null ? printer : new CodePrinter();
}

/**
 * Generates a field for any element that has either event listeners or data
 * bindings.
 */
void emitDeclarations(ElementInfo info, Declarations declarations) {
  if (!info.isRoot) {
    var type = (info.node.namespace == 'http://www.w3.org/2000/svg')
        ? 'autogenerated_svg.SvgElement'
        : 'autogenerated.${typeForHtmlTag(info.node.tagName)}';
    declarations.add(type, info.identifier);
  }
}

/** Initializes fields and variables pointing to a HTML element.  */
void emitInitializations(ElementInfo info,
    CodePrinter printer, CodePrinter childrenPrinter) {
  var id = info.identifier;
  if (info.createdInCode) {
    printer.add("$id = ${_emitCreateHtml(info.node)};");
  } else if (!info.isRoot) {
    var parentId = '_root';
    for (var p = info.parent; p != null; p = p.parent) {
      if (p.identifier != null) {
        parentId = p.identifier;
        break;
      }
    }
    printer.add("$id = $parentId.query('#${info.node.id}');");
  }

  printer.add(childrenPrinter);

  if (info.childrenCreatedInCode && !info.hasIterate && !info.hasIfCondition) {
    var nodes = info.children.mappedBy(_createChildExpression);
    _emitAddNodes(printer, nodes, '$id.nodes');
  }
}

/**
 * Emit statements that add 1 or more HTML nodes directly as children of
 * [target] (which can be a template or another node.
 */
_emitAddNodes(CodePrinter printer, Iterable<String> nodes, String target) {
  if (nodes.length == 1) {
    printer.add("$target.add(${nodes.single});");
  } else if (nodes.length > 0) {
    printer.add("$target.addAll([\n${nodes.join(',\n')}\n]);");
  }
}

/**
 * Generates event listeners attached to a node and code that attaches/detaches
 * the listener.
 */
void emitEventListeners(ElementInfo info, CodePrinter printer) {
  var id = info.identifier;
  info.events.forEach((name, events) {
    for (var event in events) {
      // Note: the name $event is from AngularJS and is essentially public
      // API. See issue #175.
      printer.add('__t.listen($id.on.${event.eventName},'
          ' (\$event) { ${event.action(id)}; });');
    }
  });
}

/** Emits attributes with some form of data-binding. */
void emitAttributeBindings(ElementInfo info, CodePrinter printer) {
  info.attributes.forEach((name, attr) {
    if (attr.isClass) {
      _emitClassAttributeBinding(info.identifier, attr, printer);
    } else if (attr.isStyle) {
      _emitStyleAttributeBinding(info.identifier, attr, printer);
    } else if (attr.isSimple) {
      _emitSimpleAttributeBinding(info, name, attr, printer);
    } else if (attr.isText) {
      _emitTextAttributeBinding(info, name, attr, printer);
    }
  });
}

// TODO(jmesserly): many methods were changed to add extra parenthesis to work
// around a VM parse bug with the greater than sign: http://dartbug.com/7869
// In the meantime we add parens. Remove these once the VM bug is fixed. You
// can find them by searching for () =>
void _emitClassAttributeBinding(
    String identifier, AttributeInfo attr, CodePrinter printer) {
  for (int i = 0; i < attr.bindings.length; i++) {
    printer.add('__t.bindClass($identifier, () => (${attr.bindings[i]}));');
  }
}

void _emitStyleAttributeBinding(
    String identifier, AttributeInfo attr, CodePrinter printer) {
  printer.add('__t.bindStyle($identifier, () => (${attr.boundValue}));');
}

void _emitSimpleAttributeBinding(ElementInfo info,
    String name, AttributeInfo attr, CodePrinter printer) {
  var binding = attr.boundValue;
  var field = _findDomField(info, name);
  var isUrl = urlAttributes.contains(name);
  printer.add('__t.oneWayBind(() => ($binding), '
        '(e) { ${info.identifier}.$field = e; }, $isUrl);');
  if (attr.customTwoWayBinding) {
    printer.add('__t.oneWayBind(() => ${info.identifier}.$field, '
          '(__e) { $binding = __e; });');
  }
}

void _emitTextAttributeBinding(ElementInfo info,
    String name, AttributeInfo attr, CodePrinter printer) {
  var textContent = attr.textContent.mappedBy(escapeDartString).toList();
  var setter = _findDomField(info, name);
  var content = new StringBuffer();
  var binding;
  if (attr.bindings.length == 1) {
    binding = attr.boundValue;
    content.add(textContent[0]);
    content.add('\${__e.newValue}');
    content.add(textContent[1]);
  } else {
    // TODO(jmesserly): we could probably do something faster than a list
    // for watching on multiple bindings.
    binding = '[${Strings.join(attr.bindings, ", ")}]';

    for (int i = 0; i < attr.bindings.length; i++) {
      content.add(textContent[i]);
      content.add("\${__e.newValue[$i]}");
    }
    content.add(textContent.last);
  }

  var exp = "'$content'";
  if (urlAttributes.contains(name)) {
    exp = 'autogenerated.sanitizeUri($exp)';
  }
  printer.add("__t.bind(() => ($binding), "
      " (__e) { ${info.identifier}.$setter = $exp; });");
}

/** Generates watchers that listen on data changes and update text content. */
void emitContentDataBinding(TextInfo info, CodePrinter printer) {
  printer.add(
      "var ${info.identifier} = __t.contentBind(() => (${info.binding}));");
}

/**
 * Emits code for web component instantiation. For example, if the source has:
 *
 *     <x-hello>John</x-hello>
 *
 * And the component has been defined as:
 *
 *    <element name="x-hello" extends="div" constructor="HelloComponent">
 *      <template>Hello, <content>!</template>
 *      <script type="application/dart"></script>
 *    </element>
 *
 * This will ensure that the Dart HelloComponent for `x-hello` is created and
 * attached to the appropriate DOM node.
 */
void emitComponentCreation(ElementInfo info, CodePrinter printer) {
  var component = info.component;
  if (component == null) return;
  var id = info.identifier;
  printer.add('new ${component.constructor}.forElement($id);')
         .add('__t.component($id);');
}

/**
 * Emits code for template conditionals like `<template instantiate="if test">`
 * or `<td template instantiate="if test">`.
 */
void emitConditional(TemplateInfo info, CodePrinter printer,
    Context childContext) {
  var cond = info.ifCondition;
  printer.add('__t.conditional(${info.identifier}, () => ($cond), (__t) {')
         .add(childContext.declarations)
         .add(childContext.printer);
  _emitAddNodes(printer, info.children.mappedBy(_createChildExpression), '__t');
  printer.add('});\n');
}

/**
 * Emits code for template lists like `<template iterate='item in items'>` or
 * `<td template iterate='item in items'>`.
 */
void emitLoop(TemplateInfo info, CodePrinter printer, Context childContext) {
  var id = info.identifier;
  var items = info.loopItems;
  printer.add('__t.loop($id, () => ($items), (${info.loopVariable}, __t) {')
      .add(childContext.declarations)
      .add(childContext.printer);
  _emitAddNodes(printer, info.children.mappedBy(_createChildExpression), '__t');
  printer.add(info.isTemplateElement ? '});' : '}, isTemplateElement: false);');
}


/**
 * An visitor that applies [NodeFieldEmitter], [EventListenerEmitter],
 * [DataValueEmitter], [ConditionalEmitter], and
 * [ListEmitter] recursively on a DOM tree.
 */
class RecursiveEmitter extends InfoVisitor {
  final FileInfo _fileInfo;
  Context _context;

  RecursiveEmitter(this._fileInfo, this._context);

  // TODO(jmesserly): currently visiting of components declared in a file is
  // handled separately. Consider refactoring so the base visitor works for us.
  visitFileInfo(FileInfo info) => visit(info.bodyInfo);

  void visitElementInfo(ElementInfo info) {
    if (info.identifier == null) {
      // No need to emit code for this node.
      super.visitElementInfo(info);
      return;
    }

    var childPrinter = new CodePrinter();
    emitDeclarations(info, _context.declarations);
    emitInitializations(info, _context.printer, childPrinter);
    emitEventListeners(info, _context.printer);
    emitAttributeBindings(info, _context.printer);
    emitComponentCreation(info, _context.printer);

    var childContext = null;
    if (info.hasIfCondition) {
      childContext = new Context();
      emitConditional(info, _context.printer, childContext);
    } else if (info.hasIterate) {
      childContext = new Context();
      emitLoop(info, _context.printer, childContext);
    } else {
      childContext = new Context(declarations: _context.declarations,
          printer: childPrinter, isClass: _context.isClass);
    }

    // Invoke super to visit children.
    var oldContext = _context;
    _context = childContext;
    super.visitElementInfo(info);
    _context = oldContext;
  }

  void visitTextInfo(TextInfo info) {
    if (info.identifier != null) {
      emitContentDataBinding(info, _context.printer);
    }
    super.visitTextInfo(info);
  }
}

/** Generates the class corresponding to a single web component. */
class WebComponentEmitter extends RecursiveEmitter {
  final Messages messages;

  WebComponentEmitter(FileInfo info, this.messages)
      : super(info, new Context(isClass: true));

  String run(ComponentInfo info, PathInfo pathInfo) {
    _context.declarations.add('autogenerated.Template', '__t');
    var elemInfo = info.elemInfo;

    // elemInfo is pointing at template tag (no attributes).
    assert(elemInfo.node.tagName == 'element');
    for (var childInfo in elemInfo.children) {
      var node = childInfo.node;
      if (node.tagName == 'template') {
        elemInfo = childInfo;
        break;
      }
    }

    if (info.element.attributes['apply-author-styles'] != null) {
      _context.printer.add('if (_root is autogenerated.ShadowRoot) '
          '_root.applyAuthorStyles = true;');
      // TODO(jmesserly): warn at runtime if apply-author-styles was not set,
      // and we don't have Shadow DOM support? In that case, styles won't have
      // proper encapsulation.
    }
    if (info.template != null && !elemInfo.childrenCreatedInCode) {
      // TODO(jmesserly): we need to emit code to run the <content> distribution
      // algorithm for browsers without ShadowRoot support.
      _context.printer.addRaw("_root.innerHtml = '''")
          .addRaw(escapeDartString(elemInfo.node.innerHTML, triple: true))
          .addRaw("''';\n");
    }

    visit(elemInfo);

    bool hasExtends = info.extendsComponent != null;
    var codeInfo = info.userCode;
    if (codeInfo == null) {
      var superclass = hasExtends ? info.extendsComponent.constructor
          : 'autogenerated.WebComponent';
      codeInfo = new DartCodeInfo(null, null, [],
          'class ${info.constructor} extends $superclass {\n}');
    }

    var code = codeInfo.code;
    var match = new RegExp('class ${info.constructor}[^{]*{').firstMatch(code);
    if (match != null) {
      var printer = new CodePrinter();
      var libraryName = (codeInfo.libraryName != null)
          ? codeInfo.libraryName
          : info.tagName.replaceAll(new RegExp('[-./]'), '_');
      printer.add(codegen.header(info.declaringFile.path, libraryName));

      // Add exisitng import, export, and part directives.
      for (var directive in codeInfo.directives) {
        printer.add(codegen.directiveText(directive, info, pathInfo));
      }

      // Add imports only for those components used by this component.
      var imports = info.usedComponents.keys.mappedBy(
          (c) => pathInfo.relativePath(info, c));

      if (hasExtends) {
        // Inject an import to the base component.
        printer.add(codegen.importList(
            [pathInfo.relativePath(info, info.extendsComponent)]));
      }

      printer.add(codegen.importList(imports))
          .add(code.substring(0, match.end))
          .add('\n')
          .add(codegen.componentCode(info.constructor,
              _context.declarations.formatString(1),
              _context.printer.formatString(2),
              _clearFields(_context.declarations),
              hasExtends))
          .add(code.substring(match.end));
      return printer.formatString();
    } else {
      messages.error('please provide a class definition '
          'for ${info.constructor}:\n $code', info.element.sourceSpan,
          file: info.inputPath);
      return '';
    }
  }
}

/** Generates the class corresponding to the main html page. */
class MainPageEmitter extends RecursiveEmitter {
  MainPageEmitter(FileInfo fileInfo) : super(fileInfo, new Context());

  String run(Document document, PathInfo pathInfo) {
    visit(_fileInfo.bodyInfo);

    // fix up the URLs to content that is not modified by the compiler
    document.queryAll('script').forEach((tag) {
    var src = tag.attributes["src"];
     if (tag.attributes['type'] == 'application/dart') {
       tag.remove();
     } else if (src != null) {
       tag.attributes["src"] = pathInfo.transformUrl(_fileInfo.path, src);
     }
    });
    document.queryAll('link').forEach((tag) {
     var href = tag.attributes['href'];
       if (tag.attributes['rel'] == 'components') {
         tag.remove();
       } else if (href != null) {
         tag.attributes['href'] = pathInfo.transformUrl(_fileInfo.path, href);
       }
     });

    var printer = new CodePrinter();

    // Inject library name if not pressent.
    var codeInfo = _fileInfo.userCode;
    if (codeInfo == null) {
      codeInfo = new DartCodeInfo(null, null, [], 'main(){\n}');
    }
    var libraryName = codeInfo.libraryName != null
        ? codeInfo.libraryName : _fileInfo.libraryName;
    printer.add(codegen.header(_fileInfo.path, libraryName));

    // Add exisitng import, export, and part directives.
    for (var directive in codeInfo.directives) {
      printer.add(codegen.directiveText(directive, _fileInfo, pathInfo));
    }

    // Import only those components used by the page.
    var imports = _fileInfo.usedComponents.keys.mappedBy(
          (c) => pathInfo.relativePath(_fileInfo, c));
    var mainCode = codegen.mainDartCode(
        codeInfo.code, _context.declarations.formatString(1),
        _context.printer.formatString(1));
    printer.add(codegen.importList(imports)).addRaw(mainCode);
    return printer.formatString();
  }
}

/** Clears all fields in [declarations]. */
String _clearFields(Declarations declarations) {
  if (declarations.declarations.isEmpty) return '';
  var buff = new StringBuffer();
  for (var d in declarations.declarations) {
    buff.add('${d.name} = ');
  }
  buff.add('null;');
  return buff.toString();
}

String _createChildExpression(NodeInfo info) {
  if (info.identifier != null) return info.identifier;
  return _emitCreateHtml(info.node);
}

/**
 * An (runtime) expression to create the [node]. It always includes the node's
 * attributes, but only includes children nodes if [includeChildren] is true.
 */
String _emitCreateHtml(Node node) {
  if (node is Text) {
    return "new autogenerated.Text('${escapeDartString(node.value)}')";
  }

  // Namespace constants from:
  // http://dev.w3.org/html5/spec/namespaces.html#namespaces
  var isHtml = node.namespace == 'http://www.w3.org/1999/xhtml';
  var isSvg = node.namespace == 'http://www.w3.org/2000/svg';
  var isEmpty = node.attributes.length == 0 && node.nodes.length == 0;

  var constructor;
  // Generate precise types like "new ButtonElement()" if we can.
  if (isEmpty && isHtml) {
    constructor = htmlElementConstructors[node.tagName];
    if (constructor != null) {
      constructor = '$constructor()';
    } else {
      constructor = "Element.tag('${node.tagName}')";
    }
  } else if (isEmpty && isSvg) {
    constructor = "_svg.SvgElement.tag('${node.tagName}')";
  } else {
    // TODO(sigmund): does this work for the mathml namespace?
    var target = isSvg ? '_svg.SvgElement.svg' : 'Element.html';
    constructor = "$target('${escapeDartString(node.outerHTML)}')";
  }
  return 'new autogenerated.$constructor';
}

/**
 * Finds the correct expression to set an HTML attribute through the DOM.
 * It is important for correctness to use the DOM setter if it is available.
 * Otherwise changes will not be applied. This is most easily observed with
 * "InputElement.value", ".checked", etc.
 */
String _findDomField(ElementInfo info, String name) {
  var typeName = typeForHtmlTag(info.baseTagName);
  while (typeName != null) {
    var fields = htmlElementFields[typeName];
    if (fields != null) {
      var field = fields[name];
      if (field != null) return field;
    }
    typeName = htmlElementExtends[typeName];
  }
  // If we didn't find a DOM setter, and this is a component, set a property on
  // the component.
  if (info.component != null && !name.startsWith('data-')) {
    return 'xtag.${toCamelCase(name)}';
  }
  return "attributes['$name']";
}
